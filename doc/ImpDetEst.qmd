---
title: "Great Blue Heron Survey 2015 and 2023"
author: "Mark C. Otto"
date: "10 July 2024"
echo: false
format: docx
editor: source
---

## Introduction

## Use data augmentation Royle and Dorazio, 2008. p. 211--224 to

Great blue heron dual-frame survey 2015

Estimation with random observer effects

```{r SetUp}
library(MASS)
library(DualFrame)
library(CollisionModel)
library(dplyr)
library(tidyr)
library(lme4)
library(rjags)
library(runjags)
library(modeest)
library(R2WinBUGS)
library(xlsx)

source("/Users/MOtto/Ref/RLib/logit.R")
source("/Users/MOtto/Ref/RLib/expit.R")
source(here::here("R/Beta.R"))
source(here::here("R/MkSmry.R"))

# Load the data
load(file = here::here("output/GBHE.RData"))
load(file =here::here("output/CochranEst.RData"))
Probs<-c(0.5,0.05,0.95)
cMdl <- "DFCH1dDA" 
File<-paste("Doc/Notes/",cMdl,".xlsx",sep="")

```

## Loaded Data

```{r LoadedData}

# cFrame, RecObs,RecObsArea, NewSmpObs, SmpColObs GrndObs -> GroundObs, cFS, AllCol -> AllColonies, 
#  
#  List nests per colony model: only stratum and frame effects
# FSEst, FSVar
# LastFirst, cObsr, nObsr, ObsrSeat
# RearAreaObsr, nRearAreaObsr, cCHCol 

```

## Occupancy Proportion

This is a rough estimate, so just do an overall.  Convert the logistic estimates in to proportions with simulations, then get the mean and standard deviations.  Since this is a random effect we need the Beta $nu$ and $nu'$.  Use the\ `Beta`\ function to get it

```{r OccProp}
OccMdl <- glm(I(Act > 0) ~ 1, family = binomial, data = SmpColObs)
summary(OccMdl)
Sim <- expit(rvnorm(1, mean = coefficients(OccMdl), sd = sqrt(vcov(OccMdl))))
OccEst <- rvmean(Sim)
OccSD <- rvsd(Sim)
OccBeta <- Beta(Mean = OccEst, SD = OccSD)

```

## Poisson GLM New Colony Model

New colony per full plot GLM model with year-stratum effects

```{r GLMNewCol}
tSmpColObs <- SmpColObs %>%
  mutate(
    Year = factor(Year, cYear)
  )
NpCGLM <- glm(
  Nest ~ FS - 1,
  data = SmpColObs,
  family = poisson
#  ,offset = log(KMSq / 100)
)
NpCYrpStrGLM <- glm(
  Nest ~ Str + Year - 1,
  data = tSmpColObs,
  family = poisson
#  ,offset = log(KMSq / 100)
)
summary(NpCYrpStrGLM)

NpCYrGLM <- glm(
  Nest ~ Year - 1,
  data = tSmpColObs,
  family = poisson
#  ,offset = log(KMSq / 100)
)
summary(NpCYrGLM)

NpCLME <- glmer(
  Nest ~ 1 + (1|FS),
  data = SmpColObs,
  family = poisson
#  ,offset = log(KMSq / 100)
)
summary(NpCLME)
AIC(NpCGLM, NpCYrpStrGLM, NpCLME)



# Estimates are on the log scale.
# Use the unconditional mean and variance to estimate missing
# effects
tNpCEst <- coef(NpCLME)$FS
NpCEst <- rep(NA, nFS)
names(NpCEst) <- cFS
NpCEst[rownames(tNpCEst)] <-tNpCEst$"(Intercept)"
NpCEst[is.na(NpCEst)] <- mean(NpCEst, na.rm = TRUE)
NpCVar <- diag(as.numeric(vcov(NpCLME)), nFS) + 
               as.numeric(VarCorr(NpCLME))

# nFS by (nYear -1) + (nFrame -1) + nStr Design matrix
ToStr <- rbind(cbind(diag(nStr), 0), 
               cbind(diag(nStr), 0),
               cbind(diag(nStr), 1), 
               cbind(diag(nStr), 1))
NpCEst <- coefficients(NpCYrpStrGLM)
NpCVar <- vcov(NpCYrpStrGLM)

```

## Proportion of Active Nest

```{r ActiveNests}
# Dropping `Frame` lowered the AIC.
ActGLM <- glm(cbind(Act, Nest - Act) ~ FS - 1, 
              data = SmpColObs, family = binomial)
summary(ActGLM)
ActLME <- glmer(cbind(Act, Nest - Act) ~ 1 + (1 | FS),
                data = SmpColObs,
                family = binomial)
summary(ActLME)
AIC(ActGLM, ActLME)

# Fill in the combinations with data
# Estimates are on the log scale.
# Use the unconditional mean and variance to estimate missing
# effects
tActEst <- coef(ActLME)$FS
ActEst <- rep(NA, nFS)
names(ActEst) <- cFS
ActEst[rownames(tActEst)] <-tActEst$"(Intercept)"
NAIdx <- is.na(ActEst)
ActEst[NAIdx] <- mean(ActEst, na.rm = TRUE)
ActVar <- diag(as.numeric(vcov(ActLME)), nFS) + 
               as.numeric(VarCorr(ActLME))

Sim <- expit(mvrnorm(n = nSim, mu = ActEst , 
                     Sigma = ActVar))
ActLMEEst <- apply(Sim, 2, mean, na.rm = TRUE)
ActLMESD <- apply(Sim, 2, sd, na.rm = TRUE)
pActBeta <- Beta(Mean = mean(ActLMEEst), 
        SD = sqrt(var(ActLMEEst) + mean(ActLMESD ^ 2)))

```

## Create Augmented Data
Create augmented data for each combination of year and stratum.
`inCNA`\ seems to be augmented or not.  It is not used.
Keep the rear observer initials for a more complicated analysis.

```{r AugmentedData}
# Augmented data
nAug <- 50
tmp <- expand_grid(
  Year = cYear,
  Str = cDFStr,
  inCNA = TRUE,
  CapHist = paste("DD", "RR", sep = "."),
  Front = "DD",
  Rear = RearAreaObsr,
  FWSColonyID = sprintf("DA.%04d", 1:nAug),
  `01` = 0,
  `10` = 0,
  `11` = 0,
  `00` = 1
) %>%
  mutate(
    FRObsr = paste("DD", Rear, sep = "."),
    sprintf("DA.%04d", row_number())
  ) %>%
  select(
    Year,
    Str,
    inCNA,
    Front,
    Rear,
    FWSColonyID,
    FRObsr,
    `01`,
    `10`,
    `11`,
    `00`)
nACH <- nrow(tmp)
cDAFWSColonyID <- sprintf("DA.%04d", 1:nACH)
tmp$FWSColonyID <- cDAFWSColonyID

# Combine the observed capture histories with the augmented data
# The augmented capture histories are not seen by both, CH = `00`.
# The observed capture histories had to have some sighting.
# They could have missed it in the area search but found in the
# list check.
CapHistAug <- bind_rows(CapHist, tmp) %>%
  mutate(
    CapHist2Year = factor(Year, cYear),
    CapHist2Str = factor(Str, cDFStr),
    CapHist2YrStr = factor(paste(Year, Str, sep = "."), cYrStr)
  )
rm(tmp)

```

Relate the ColonyID to the record in Nest, so the nest ID are the same All new codes would get the same id.  
Not sure how this relates.

```{r AugmentedColonies}
cFWSColonyID <- sort(unique(c(RecObs$FWSColonyID, Colony$FWSColonyID)))
cColLvl <- sort(unique(c(cFWSColonyID, cDAFWSColonyID)))
Cmb2Col <- as.numeric(factor(CapHistAug$FWSColonyID, cColLvl))
sum(duplicated(CapHistAug$FWSColonyID)) # the new colonies

# Only used for observer detection, not seat detection.
Grp <- rbind(match(CapHistAug$Front, cObsr), match(CapHistAug$Rear, cObsr))

```

## Observer Detection
`CapHist`\ is the list of capture histories.  These determine the observer probabilities.  For each colony the detection is determined by the size of the colony, the observer detection, and the seat.  Observer and seat are confounded because Danielle D'Auria was always in the front seat and the other observers in the rear.  The ground detection was assumed to be 1.

Coefficient matrix for 0O, P0, and PO

```{r ObsMtx}
nObsrs <- 2
# nCH are all possible combination of two observers seeing of not seeing the colony or the nest.
nCH <- 2 ^ nObsrs
MltObsr <- matrix(
  0,
  nrow = nrow(CapHistAug),
  ncol = length(cCHCol),
  dimnames = list(CapHistAug$FWSColonyID, cCHCol)
)
MltObsr[, ] <- as.matrix(CapHistAug[, c("01", "10", "11", "00")])
dimnames(MltObsr) <- NULL

# Colony indicator to match number of nests in colonies
Obs2Col <- as.numeric(SmpColObs$FWSColonyID)
Obs2Obsr <- as.numeric(SmpColObs$Obsr)
Obs2Str <- as.numeric(SmpColObs$Str)

```

## Area Sample

List of colonies by `FS`, list and new.

```{r NewColonies}
# Number of new colonies by year and stratum: NewSmry
# NewColSmp <- NewSmry$SmpCol # and isn't used.

# Make factor indices for `FS`: year-frame-stratum and `Str`
# All2FS <- as.numeric(AllCol$FS)
# All2Str <- as.numeric(factor(AllCol$Str, cStr[1:nStr]))

```

## JAGS Data

```{r JAGSData}
# Model data
Data <- list(
  nStr = nStr,
  nYrStr = nYrStr,
  nFS = nFS,
  nNewCol = nNewCol,
  nObsr = nObsr,
  nColObs = nrow(SmpColObs),
  nest = SmpColObs$Nest,
  act = SmpColObs$Act,
  Obs2Col = Obs2Col,
  Obs2Obsr = Obs2Obsr,
  ToStr = ToStr,
  nCH = nCH,
  nAugCol =
  Cmb2Col = Cmb2Col,
  nCmb = nrow(MltObsr),
  xCH = t(MltObsr),
  Grp = Grp,
  # Nest and active nests per colony
  nACH = nACH,
  nLstCol = nLstCol,
  #,All2FS = All2FS,
  # All2Str = All2Str,
  
  # Estimates
  ExpFac = ExpFac$ExpFac
)

```

## Initial value function

```{r InitialValueFunction}
InitFcn <- function(iChain) {
  # Colony occupancy proportion random effect Beta parameters
  ColPsiNu <- rnorm(n = 1, mean = OccBeta$nu, sd = OccBeta$nu / 10)
  ColPsiNup <- rnorm(1, OccBeta$nup, OccBeta$nup / 10)
  
  # Nest per colony stratum + year model
  lnNpCFS <- mvrnorm(n = 1, mu = NpCEst, Sigma = NpCVar)
  
  # Colony nestws proportion active random effect Beta parameters
  pActNu <- rnorm(1, pActBeta$nu, pActBeta$nu / 10)
  pActNup <- rnorm(1, pActBeta$nup, pActBeta$nup / 10)
  
  list(
    ColPsiNu = ColPsiNu,
    ColPsiNup = ColPsiNup,
    lnNpCFS = lnNpCFS,
    pActNu = pActNu,
    pActNup = pActNup,
    lgtObsr = rnorm(nObsr - 1, 0.89, 0.5)
  )
}

```

## Monitored Parameters

```{r ParmMonitor}
Parm <- c(
  "LstColTot",
  "LstActColTot",
  "LstNestTot",
  "LstActTot",
  "NewColTot",
  "NewActColTot",
  "NewNestTot",
  "NewActTot",
  "NpC",
  "pAct",
  "pObsr",
  "pNest2Col",
  "ObsrMu",
  "ObsrSD",
  "dic"
)
cParm <- c(
  #   sub("new","n",sub("ME","N",ColObs$FWSColonyID)),
  #  list occupied colonies
  paste("LCT", cYrStr, sep = ""),
  #  list active colonies
  paste("LAC", cYrStr, sep = ""),
  #  list nests
  paste("LNT", cYrStr, sep = ""),
  #  list active nests
  paste("LAT", cYrStr, sep = ""),
  #  new occupied colonies
  paste("NCT", cYrStr, sep = ""),
  #  new active colonies
  paste("NAC", cYrStr, sep = ""),
  #  new nests
  paste("NNT", cYrStr, sep = ""),
  #  new active nests
  paste("NAT", cYrStr, sep = ""),
  # Nests per Colony
  paste("NpC", sub(
    "\\.Area\\.", "a", sub("\\.List\\.", "l", cFS)
  ), sep = ""),
  # Proportion active nests per colony
  paste("pA", cFS, sep = ""),
  # Observer detection rates
  paste("pO", cObsr, sep = "."),
  # Extra difficuly to detect colonies over nests in colonies
  "pNest2Col",
  # Observer detection random effect parmeters.
  "ObsrMu",
  "ObsrSD",
  # Model deviance (could not monitor DIC)
  "Dev"
)
nParm <- length(cParm)

```

## Simulation and Initialization Parameters

```{r SimInitParms}
nChain <- 4
nSim <- 50000    # Number of simulations desired
setnsims(nSim)
getnsims()
nThin <- 1
pctBurn <- 50
nBurn <- floor(nThin * nSim * pctBurn / (100 - pctBurn))
DebugMe <- FALSE

# set.seed(Save.Seed)
Inits <- sapply(1:nChain, InitFcn, simplify = FALSE)

# JAGS model
BUGSMdl <-
  paste(readLines(here::here(paste(
    "extdata/", cMdl, ".mdl", sep =
      ""
  ))), collapse = "\n")

```

## Save JAGS Model Setup

```{r SaveSetUp}
 # Run JAGS
unlink("runjagsfiles")
save(
  cMdl,
  nChain,
  nSim,
  nThin,
  pctBurn,
  nBurn,
  DebugMe,
  Data,
  Inits,
  InitFcn,
  Parm,
  cParm,
  nParm,
  BUGSMdl,
  file = here::here(paste("TmpData/", cMdl, ".RData", sep = ""))
)

```

## Run JAGS Bayesian Estimation

```{r RunJAGS}
if (exists("MCMC"))
  rm(MCMC)
runjags.options(force.summary = TRUE)
runjags.getOption("force.summary")
MCMC <- run.jags(
  model = BUGSMdl,
  monitor = c(Parm, "deviance", "pd"),
  data = Data,
  n.chains = nChain,
  inits = Inits,
  jags = findjags(look_in = if (file.exists("M:/"))
    "C:/Workspace/JAGS"
    else
      NA),
  method = "interruptible",
  burnin = nBurn,
  sample = nSim * nThin,
  thin = nThin,
  modules = "dic",
  plots = FALSE,
  keep.jags.files = TRUE,
  tempdir = TRUE
)

# MCMC<-extend.jags(MCMC,sample=50000)
plot(MCMC, plot.type = "trace", vars = "NewActColTot")

# iObs<-159;Data$act[iObs];iCol<-Obs2Col[iObs];sapply(1:4,function(i)Inits[[i]]$Act[iCol])
# iObsr<-Obs2Obsr[iObs];sapply(1:4,function(i)Inits[[i]]$lgtObsr[iCol])
 
```

## Combine Chain Simulations

```{r CombineChains}

#  Didn't summarize
 if (FALSE) {
   tMCMC <-
     combine.mcmc(lapply(1:nChain, function(iChain,
                                            JagsDir = "",
                                            Start = 1) {
       read.coda(
         paste("runjagsfiles", JagsDir, "/CODAchain", iChain, ".txt", sep = ""),
         paste("runjagsfiles", JagsDir, "/CODAindex.txt", sep = ""),
         start = Start
       )
     }, JagsDir = "", Start = 1))
   
   MCMC$mcmc <- tMCMC
   tmp <- summary(tMCMC, na.rm = TRUE)
   MCMC$summary$statistics <- tmp$statistics
   MCMC$HPD <- tmp$quantiles
 }
 
 PostStat <- data.frame(MCMC$summary$statistics[, 1:2],
                        MCMC$HPD[, c(2, 1, 3)])
 colnames(PostStat)[3:5] <- c("median", "lower95", "upper95")
 # cPS<-rownames(PostStat);cPS;cParm
 rownames(PostStat) <- cParm
 
```

## Print JAGS Estimates

```{r PrintJAGS}
sink(here::here(sub("xlsx", "txt", File)), append = FALSE)
cat("Posteriors\n")
cat("List and List: Colony Total and Active and Nest Total and Active by Stratum\n")
print(PostStat[1:(8 * nStr), ], digits = 3)
cat("Nest per Colony\n")
print(PostStat[8 * nStr + 1:(2 * nStr), ], digits = 4)
cat("Proportion Active\n")
print(100 * PostStat[10 * nStr + 1:nStr, ], digits = 2)
cat("Observer Detection Probabilities\n")
print(100 * PostStat[11 * nStr + 1:nObsr, ], digits = 2)
cat("pNest2Col,Detection RE Mean and SD\n")
print(PostStat[nParm+-3:-1, ], digits = 3)
cat("Deviance\n")
print(PostStat[nParm, ], digits = 3)
sink()

```

## Save JAGS Summaries

```{r JAGSSave}
 save(
   Data,
   nChain,
   nSim,
   nThin,
   pctBurn,
   nBurn,
   MCMC,
   PostStat,
   file = paste("TmpData/", cMdl, ".PS.RData", sep = "")
 )

```

## Simulate the Estimates

```{r SimEsts}
 # load(paste("TmpData/",cMdl,".PS.RData",sep=""))
 # Extract the 
# tmp4<-tMCMC
 nSim<-dim(MCMC$mcmc[[1]])[1]
 tmp<-MCMC$mcmc
 tmp2<-unlist(c(tmp[[1]],tmp[[2]],tmp[[3]],tmp[[4]]))

 tmp3<-array(tmp2,c(nSim,nParm,nChain))
 
 cPS<-dimnames(tmp[[1]])[[2]]
 
 tmp4<-aperm(tmp3,c(1,3,2))
 Dim4 <- dim(tmp4) 
 
 tmp5<-tmp4[(Dim4[1]/5 + 1):nSim,,]
 nSim<-dim(tmp5)[1]
 tmp4<-tmp5
 dim(tmp4)<-c(nSim*nChain,nParm)
 setnsims(nSim)

# str(tmp4)
# These are just for the sample in the list frame
 for(iParm in Parm){
   Idx<-grep(iParm,cPS)
   assign(iParm,rvsims(tmp4[,Idx]))
 }

```

## Make Output Tables

```{r MakeTables}

 TblLoc<-read.table(
   textConnection("Table,Row,Col,Sheet,Title
PostStat,3,1,MdlParm,'Model Parmeters'
LstColSmry,4,3,Estimates,'List Colonies'
LstActColSmry,9,3,Estimates,'Active List Colonies'
LstNestSmry,14,3,Estimates,'List Nest per Colony'
LstActSmry,19,3,Estimates,'Active per Colony'
NewColSmry,4,9,Estimates,'New Colonies'
NewActColSmry,9,9,Estimates,'New Active Colonies'
NewNestSmry,14,9,Estimates,'New Nests'
NewActSmry,19,9,Estimates,'New Active Nests'
DFColSmry,4,15,Estimates,'Dual-Frame Colonies'
DFActColSmry,9,15,Estimates,'Dual-Frame Colonies'
DFNestSmry,14,15,Estimates,'Dual-Frame Colonies'
DFActSmry,19,15,Estimates,'Dual-Frame Active Colonies'
DFMean,4,23,Estimates,'Dual-Frame Means'
DFSD,9,23,Estimates,'Dual-Frame SDs'
CVSmry,14,23,Estimates,'Coefficients of Variation'
PctLstCovSmry,24,3,Estimates,'Percent List Coverage'
PctObsrDetSmry,3,3,'Obsr Det','Percent Observer Detection'
"),sep=",",header=TRUE,stringsAsFactors=FALSE)
 
# Dual-Frame Estimates
 # Colonies
 DFColTot<-LstColTot+NewColTot
 DFActColTot<-LstActColTot+NewActColTot
 DFNestTot<-LstNestTot+NewNestTot
 DFActTot<-LstActTot+NewActTot

 for(iTbl in TblLoc[c(2:9,10:13),"Table"]){
# iTbl<-TblLoc[13,"Table"]
   iTot<-sub("Smry","Tot",iTbl)
   assign(iTbl,eval(parse(text=paste("MkSmry(",iTot,")"))))
#   assign(iTbl,eval(parse(text=paste("RVSmry(Series=",iTot,",probs=Probs)"))))
 }

# List coverage
 PctLstCovTot<-c(100*LstColTot/DFColTot,100*sum(LstColTot)/sum(DFColTot))

# Estimates summary in terms of active nests
 DFMean<-data.frame(
   List=LstActSmry$Mean,
   New=NewActSmry$Mean,
   DF=DFActSmry$Mean,
   row.names=cStr
 )
 
# SD's    
 DFSD<-data.frame(
   List=LstActSmry$SD,
   New=NewActSmry$SD,
   DF=DFActSmry$SD,
   row.names=cStr
 )
 
# Coefficient of Variation
 tLstCV<-LstActSmry%>%
   mutate(
     PctCV=100*SD/Mean
   )
 
 tNewCV<-NewActSmry%>%
   mutate(
     PctCV=100*SD/Mean
   )
 
 tDFCV<-DFActSmry%>%
   mutate(
     PctCV=100*SD/Mean
   )
 
 CVSmry<-data.frame(
   tLstCV$PctCV,tNewCV$PctCV,tDFCV$PctCV,
   row.names=cStr
 )
 colnames(CVSmry)<-c("List","New","DF")

# Percent Observer Detection
 PctObsrDetSmry<-RVSmry(Series=100*pObsr,probs=Probs)
 PctObsrDetSmry<-PctObsrDetSmry[c(4,1:3,5:nObsr),]

```

## Write the Tables

```{r WriteTables}
# Open workbook and get sheets
SmryFile <- str_sub(File, "xlsx", "Smry.xlsx")
if (file.exists(SmryFile)) {
  file.remove(SmryFile)
}
WorkBook <- loadWorkbook(SmryFile)
Sheet <- getSheets(WorkBook)

for (iTbl in 1:nrow(TblLoc)) {
  # iTbl<-1
  addDataFrame(
    eval(parse(text = TblLoc[iTbl, "Table"])),
    sheet = Sheet[[TblLoc[iTbl, "Sheet"]]],
    startRow = TblLoc[iTbl, "Row"],
    startColumn = TblLoc[iTbl, "Col"],
    col.names = FALSE,
    row.names = iTbl == 1,
    showNA = FALSE
  )
  # Title over the table
  setCellValue(cell = c(TableLoc[iTbl, "Row", ] - 1, 
                        TableLoc[iTbl, "Col"]), 
               value = TableLoc[iTbl, "Title"])
  
}

```

## Save the Data

```{r SaveData}
 saveWorkbook(wb=WorkBook, file=SmryFile) 
 
 rm(tmp,tmp2,tmp3,tmp4)
 
 rm(MCMC)
 save.image(paste("TmpData/",cMdl,".Image.RData",sep="")) 
# load(paste("TmpData/",cMdl,".Image.RData",sep="")) 
 
```
